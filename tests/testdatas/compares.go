package testdatas

import "github.com/CSKU-Lab/go-grader/models"

var Compares = []models.CompareConfig{
	{
		ID:          "default",
		BuildScript: "#!/bin/bash\n\ng++ default.cpp -o default",
		RunScript:   "#!/bin/bash\n\n./default",
		RunName:     "default",
		Files: []models.File{
			{
				Name:    "default.cpp",
				Content: "// default_validator from kattis problemtools package\n// licensed under MIT license\n//\n// modified: float comparison\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <cstdarg>\n#include <sstream>\n#include <vector>\n\nconst int EXIT_AC = 42;\nconst int EXIT_WA = 43;\n\nstd::ifstream judgein, judgeans;\nFILE *judgemessage = NULL;\nFILE *diffpos = NULL;\nint judgeans_pos, stdin_pos;\nint judgeans_line, stdin_line;\n\n/* The floating point type we use internally: */\ntypedef long double flt;\n\nvoid wrong_answer(const char *err, ...) {\n\tva_list pvar;\n\tva_start(pvar, err);\n\tfprintf(judgemessage, \"Wrong answer on line %d of output (corresponding to line %d in answer file)\\n\",\n\t\t\tstdin_line, judgeans_line);\n\tvfprintf(judgemessage, err, pvar);\n\tfprintf(judgemessage, \"\\n\");\n\tif (diffpos) {\n\t\tfprintf(diffpos, \"%d %d\", judgeans_pos, stdin_pos);\n\t}\n\texit(EXIT_WA);\n}\n\nvoid judge_error(const char *err, ...) {\n\tva_list pvar;\n\tva_start(pvar, err);\n\t// If judgemessage hasn't been set up yet, write error to stderr\n\tif (!judgemessage) judgemessage = stderr;\n\tvfprintf(judgemessage, err, pvar);\n\tfprintf(judgemessage, \"\\n\");\n\tassert(!\"Judge Error\");\n}\n\nbool isfloat(const char *s, flt &val) {\n\tchar trash[20];\n\tflt v;\n\tif (sscanf(s, \"%Lf%10s\", &v, trash) != 1) return false;\n\tval = v;\n\treturn true;\n}\n\ntemplate <typename Stream>\nvoid openfile(Stream &stream, const char *file, const char *whoami) {\n\tstream.open(file);\n\tif (stream.fail()) {\n\t\tjudge_error(\"%s: failed to open %s\\n\", whoami, file);\n\t}\n}\n\nFILE *openfeedback(const char *feedbackdir, const char *feedback, const char *whoami) {\n\tstd::string path = std::string(feedbackdir) + \"/\" + std::string(feedback);\n\tFILE *res = fopen(path.c_str(), \"w\");\n\tif (!res) {\n\t\tjudge_error(\"%s: failed to open %s for writing\", whoami, path.c_str());\n\t}\n\treturn res;\n}\n\n/* Test two numbers for equality, accounting for +/-INF, NaN and\n * precision. Float f2 is considered the reference value for relative\n * error.\n */\nint equal(flt f1, flt f2, flt float_abs_tol, flt float_rel_tol)\n{\n\tflt absdiff, reldiff;\n\t/* Finite values are compared with some tolerance */\n\tif ( std::isfinite(f1) && std::isfinite(f2) ) {\n\t\tabsdiff = fabsl(f1-f2);\n\t\treldiff = fabsl((f1-f2)/f2);\n\t\treturn !(absdiff > float_abs_tol && reldiff > float_rel_tol);\n\t}\n\t/* NaN is equal to NaN */\n\tif ( std::isnan(f1) && std::isnan(f2) ) return 1;\n\t/* Infinite values are equal if their sign matches */\n\tif ( std::isinf(f1) && std::isinf(f2) ) {\n\t\treturn std::signbit(f1) == std::signbit(f2);\n\t}\n\t/* Values in different classes are always different. */\n\treturn 0;\n}\n\n// Function to trim leading and trailing whitespace\nstd::string trim(const std::string& str) {\n    size_t first = str.find_first_not_of(\" \\t\\n\\r\");\n    if (first == std::string::npos) return \"\";\n    size_t last = str.find_last_not_of(\" \\t\\n\\r\");\n    return str.substr(first, last - first + 1);\n}\n\n// Function to trim only trailing whitespace\nstd::string trim_trailing(const std::string& str) {\n    size_t first = str.find_first_not_of(\" \\t\\n\\r\");\n    if (first == std::string::npos) return \"\";\n    size_t last = str.find_last_not_of(\" \\t\\n\\r\");\n    return str.substr(0, last + 1);\n}\n\n// Custom streams to handle trimming of trailing whitespace\nclass TrimmingStream {\nprivate:\n    std::istream& stream;\n    std::stringstream line_buffer;\n    bool buffer_empty;\n\npublic:\n    TrimmingStream(std::istream& s) : stream(s), buffer_empty(true) {}\n\n    bool getline(std::string& line) {\n        if (buffer_empty) {\n            std::string raw_line;\n            if (!std::getline(stream, raw_line)) {\n                return false;\n            }\n            line = trim_trailing(raw_line);\n            return true;\n        } else {\n            line = line_buffer.str();\n            buffer_empty = true;\n            return true;\n        }\n    }\n\n    void pushback(const std::string& line) {\n        line_buffer.str(line);\n        buffer_empty = false;\n    }\n\n    int peek() {\n        return stream.peek();\n    }\n\n    int get() {\n        return stream.get();\n    }\n};\n\nconst char *USAGE = \"Usage: %s judge_in judge_ans feedback_dir [options] < team_out\";\n\nint main(int argc, char **argv) {\n\tif(argc < 4) {\n\t\tjudge_error(USAGE, argv[0]);\n\t}\n\tjudgemessage = openfeedback(argv[3], \"judgemessage.txt\", argv[0]);\n\tdiffpos = openfeedback(argv[3], \"diffposition.txt\", argv[0]);\n\topenfile(judgein, argv[1], argv[0]);\n\topenfile(judgeans, argv[2], argv[0]);\n\n    // We need to process both judge_ans and team_out line by line, \n    // trimming trailing whitespace before comparison\n    std::string judge_line, team_line;\n    std::vector<std::string> judge_lines, team_lines;\n    \n    // Read and process judge answer file\n    while (std::getline(judgeans, judge_line)) {\n        judge_lines.push_back(trim_trailing(judge_line));\n    }\n    \n    // Read and process team output\n    while (std::getline(std::cin, team_line)) {\n        team_lines.push_back(trim_trailing(team_line));\n    }\n    \n    // Create new stringstreams with the trimmed content\n    std::stringstream trimmed_judgeans, trimmed_stdin;\n    for (const auto& line : judge_lines) {\n        trimmed_judgeans << line << '\\n';\n    }\n    \n    for (const auto& line : team_lines) {\n        trimmed_stdin << line << '\\n';\n    }\n    \n    // Clear and replace the original streams\n    judgeans.clear();\n    judgeans.seekg(0);\n    std::cin.clear();\n    \n    // Create buffer streams that will be used instead of the originals\n    std::istringstream new_judgeans(trimmed_judgeans.str());\n    std::istringstream new_stdin(trimmed_stdin.str());\n\n\tbool case_sensitive = false;\n\tbool space_change_sensitive = false;\n\tbool use_floats = false;\n\tflt float_abs_tol = -1;\n\tflt float_rel_tol = -1;\n\n\tfor (int a = 4; a < argc; ++a) {\n\t\tif        (!strcmp(argv[a], \"case_sensitive\")) {\n\t\t\tcase_sensitive = true;\n\t\t} else if (!strcmp(argv[a], \"space_change_sensitive\")) {\n\t\t\tspace_change_sensitive = true;\n\t\t} else if (!strcmp(argv[a], \"float_absolute_tolerance\")) {\n\t\t\tif (a+1 == argc || !isfloat(argv[a+1], float_abs_tol))\n\t\t\t\tjudge_error(USAGE, argv[0]);\n\t\t\t++a;\n\t\t} else if (!strcmp(argv[a], \"float_relative_tolerance\")) {\n\t\t\tif (a+1 == argc || !isfloat(argv[a+1], float_rel_tol))\n\t\t\t\tjudge_error(USAGE, argv[0]);\n\t\t\t++a;\n\t\t} else if (!strcmp(argv[a], \"float_tolerance\")) {\n\t\t\tif (a+1 == argc || !isfloat(argv[a+1], float_rel_tol))\n\t\t\t\tjudge_error(USAGE, argv[0]);\n\t\t\tfloat_abs_tol = float_rel_tol;\n\t\t\t++a;\n\t\t} else {\n\t\t\tjudge_error(USAGE, argv[0]);\n\t\t}\n\t}\n\tuse_floats = float_abs_tol >= 0 || float_rel_tol >= 0;\n\n\tjudgeans_pos = stdin_pos;\n\tjudgeans_line = stdin_line = 1;\n\n\tstd::string judge, team;\n\twhile (true) {\n\t\t// Space!  Can't live with it, can't live without it...\n\t\twhile (isspace(new_judgeans.peek())) {\n\t\t\tchar c = (char)new_judgeans.get();\n\t\t\tif (space_change_sensitive) {\n\t\t\t\tint d = new_stdin.get();\n\t\t\t\tif (c != d) {\n\t\t\t\t\twrong_answer(\"Space change error: got %d expected %d\", d, c);\n\t\t\t\t}\n\t\t\t\tif (d == '\\n') ++stdin_line;\n\t\t\t\t++stdin_pos;\n\t\t\t}\n\t\t\tif (c == '\\n') ++judgeans_line;\n\t\t\t++judgeans_pos;\n\t\t}\n\t\twhile (isspace(new_stdin.peek())) {\n\t\t\tchar d = (char)new_stdin.get();\n\t\t\tif (space_change_sensitive) {\n\t\t\t\twrong_answer(\"Space change error: judge out of space, got %d from team\", d);\n\t\t\t}\n\t\t\tif (d == '\\n') ++stdin_line;\n\t\t\t++stdin_pos;\n\t\t}\n\n\t\tif (!(new_judgeans >> judge))\n\t\t\tbreak;\n\n\t\tif (!(new_stdin >> team)) {\n\t\t\twrong_answer(\"User EOF while judge had more output\\n(Next judge token: %s)\", judge.c_str());\n\t\t}\n\n\t\tflt jval, tval;\n\t\tif (use_floats && isfloat(judge.c_str(), jval)) {\n\t\t\tif (!isfloat(team.c_str(), tval)) {\n\t\t\t\twrong_answer(\"Expected float, got: %s\", team.c_str());\n\t\t\t}\n\t\t\tif (!equal(tval, jval, float_abs_tol, float_rel_tol)) {\n\t\t\t\twrong_answer(\"Too large difference.\\n Judge: %s\\n Team: %s\\n Difference: %Lg\\n (abs tol %Lg rel tol %Lg)\",\n\t\t\t\t\t\t\t judge.c_str(), team.c_str(), fabsl(jval-tval), float_abs_tol, float_rel_tol);\n\t\t\t}\n\t\t} else if (case_sensitive) {\n\t\t\tif (strcmp(judge.c_str(), team.c_str()) != 0) {\n\t\t\t\twrong_answer(\"String tokens mismatch\\nJudge: `%s`\\nTeam: `%s`\", judge.c_str(), team.c_str());\n\t\t\t}\n\t\t} else {\n\t\t\tif(strcasecmp(judge.c_str(), team.c_str()) != 0) {\n\t\t\t\twrong_answer(\"String tokens mismatch\\nJudge: `%s`\\nTeam: `%s`\", judge.c_str(), team.c_str());\n\t\t\t}\n\t\t}\n\t\tjudgeans_pos += judge.length();\n\t\tstdin_pos += team.length();\n\t}\n\n\tif (new_stdin >> team) {\n\t\twrong_answer(\"Trailing output:\\n%s\", team.c_str());\n\t}\n\n\texit(EXIT_AC);\n}",
			},
		},
	},
}
